# 手动依赖项注入

Android 推荐应用架构建议将代码划分为多个类，这样能够更好的实现职责分离。然而这些类之间又需要依赖关系，这样才能组成一个整体。

###### 用户注册一般会涉及到如下角色：

- 界面：LoginActivity
- 界面逻辑处理：LoginViewModel
- 数据仓库管理类：UserRepository
- 数据源：UserRemoteDataSource、UserLocalDataSource
- 拿数据：Retrofit

###### 用户注册代码大致实现：

（1）根据依赖关系进行基础实现
```kotlin
class ManualLoginActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_manual_login)
        doLogin1()
    }
    
    /**
     * mock login action
     * */
    private fun doLogin1() {
        //4、网络数据源
        val retrofit = Retrofit.Builder()
            .baseUrl("https://www.baidu.com")
            .build()
            .create(LoginService::class.java)
        //3、数据源仓库依赖数据源
        val remoteDataSource = UserRemoteDataSource(retrofit)
        val localDataSource = UserLocalDataSource()
        //2、ViewModel需要一个数据仓库，数据仓库有不同的数据源：
        //(1)本地数据源
        //(2)网络数据源
        val userRepository = UserRepository(localDataSource, remoteDataSource)
        //1、ViewModel中做具体逻辑处理
        val loginViewModel = LoginViewModel(userRepository)
        loginViewModel.login()
    }
}
```
（2）用容器单例AppContainer&工厂模式优化代码。

```kotlin
    /**
     * 基于doLogin1方案进行优化:
     * 1、容器管理（不是单利模式，而达到单例效果）
     * 2、工厂模式（viewModel的创建）
     * */
    private fun doLogin2() {
        // 使用容器的方式userRepository只初始化一次，类似单例而不是单例模式。
        val myApplication = application as MyApplication
        val loginViewModel = myApplication.container.loginViewModelFactory.create()
        loginViewModel.login()
    }
```
（3）管理应用流程中的依赖项

当在项目中添加更多功能，AppContainer 会变得非常复杂。当应用变大并且可以引入不同功能流程时，还会出现更多问题：
