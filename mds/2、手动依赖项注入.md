# 手动依赖项注入

Android 推荐应用架构建议将代码划分为多个类，这样能够更好的实现职责分离。然而这些类之间又需要依赖关系，这样才能组成一个整体。

###### 用户注册一般会涉及到如下角色：

- 界面：LoginActivity
- 界面逻辑处理：LoginViewModel
- 数据仓库管理类：UserRepository
- 数据源：UserRemoteDataSource、UserLocalDataSource
- 拿数据：Retrofit

###### 用户注册代码大致实现：

（1）根据依赖关系进行基础实现
```kotlin
class ManualLoginActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_manual_login)
        doLogin1()
    }
    
    /**
     * mock login action
     * */
    private fun doLogin1() {
        //4、网络数据源
        val retrofit = Retrofit.Builder()
            .baseUrl("https://www.baidu.com")
            .build()
            .create(LoginService::class.java)
        //3、数据源仓库依赖数据源
        val remoteDataSource = UserRemoteDataSource(retrofit)
        val localDataSource = UserLocalDataSource()
        //2、ViewModel需要一个数据仓库，数据仓库有不同的数据源：
        //(1)本地数据源
        //(2)网络数据源
        val userRepository = UserRepository(localDataSource, remoteDataSource)
        //1、ViewModel中做具体逻辑处理
        val loginViewModel = LoginViewModel(userRepository)
        loginViewModel.login()
    }
}
```
（2）用容器单例AppContainer&工厂模式优化代码。

```kotlin
    /**
     * 基于doLogin1方案进行优化:
     * 1、容器管理（不是单利模式，而达到单例效果）
     * 2、工厂模式（viewModel的创建）
     * */
    private fun doLogin2() {
        // 使用容器的方式userRepository只初始化一次，类似单例而不是单例模式。
        val myApplication = application as MyApplication
        val loginViewModel = myApplication.container.loginViewModelFactory.create()
        loginViewModel.login()
    }
```
（3）管理应用流程中的依赖项

当在项目中添加更多功能时AppContainer会变得非常复杂，会出现很多问题：

举个例子吧，单例数据生命周期变长，或许不符合我们的业务预期。

如LoginUserData类用来存储用户名和密码。假如登录流程由一个 Activity (ManualLoginActivity) 和多个 Fragment（LoginUsernameFragment 和 LoginPasswordFragment）组成。这些视图需要：

- 访问需要共享的同一 LoginUserData 实例，直至登录流程完成。

- 当该流程再次开始时，创建一个新的 LoginUserData 实例。

因此我们应该再创建一个登录容器来管理这些数据，此容器需要在登录流程开始时创建，并在流程结束时将其从内存中移除。

```kotlin

    class LoginActivity: Activity() {

        private lateinit var loginViewModel: LoginViewModel
        private lateinit var loginData: LoginUserData
        private lateinit var appContainer: AppContainer

        override fun onCreate(savedInstanceState: Bundle?) {
            super.onCreate(savedInstanceState)
            appContainer = (application as MyApplication).appContainer

            // 登录流程开始，为loginContainer 实例化数据
            appContainer.loginContainer = LoginContainer(appContainer.userRepository)

            loginViewModel = appContainer.loginContainer.loginViewModelFactory.create()
            loginData = appContainer.loginContainer.loginData
        }

        override fun onDestroy() {
            //页面关闭，登录流程结束，数据移除。
            appContainer.loginContainer = null
            super.onDestroy()
        }
    }
    
```

###### 手动依赖注入的优缺点

（1）优点

依赖项注入对于创建可扩展且可测试的 Android 应用而言是一项适合的技术。将容器作为在应用的不同部分共享各个类实例的一种方式，以及使用工厂创建各个类实例的集中位置。

（2）缺点

当应用变大时，您会发现您编写了大量样板代码（例如工厂），这可能容易出错。您还必须自行管理容器的范围和生命周期，优化并舍弃不再需要的容器以释放内存。如果操作不当，可能会导致应用出现微小错误和内存泄露。

（3）解决方案：使用自动依赖注入。框架帮我们实现繁琐、易出错的任务。
