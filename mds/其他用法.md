# 普通字段的注入

普通字段可认为是基本数据类型、String、Char等这些常见的数据类型。

普通字段的注入与自定义引用类型作为字段注入方式没啥区别都要通过@Inject或者@Provides方式提供实例。但由于普通数据类型为系统提供
好的类我们只能通过@Provides方式提供实例了。

```kotlin
/**
 * Create by SunnyDay /12/13 17:04:59
 */
class CommonField @Inject constructor(val age:Int,val name: String)
```

定义Module&Provides

```kotlin
/**
 * Create by SunnyDay /12/13 17:10:52
 */
@Module
class CommonModule {
    @Provides
    fun provideAge():Int = 10
    @Provides
    fun provideName():String = "Kate"
}
```
容器管理

```kotlin
@Component(modules = [CommonModule::class])
interface ApplicationComponent {
    fun getCommonField():CommonField
}
```

# @IntoMap

@IntoSet和@IntoMap用法类似，就是把目标数据注入到指定的set或Map中，这样就避免了初始化操作，直接使用set或者map。这里就举个Map的例子。

@IntoMap需要同@IntKey或@StringKey或自定义的@MapKey以及@Provides一起使用。

例如map的key为int类型则用@IntKey，如果为自定义类型则需要自定义注解并在自定义注解上打上@MapKey。

###### 1、基本用法

```kotlin
class DaggerBasicActivity : AppCompatActivity() {
    // 1、Dagger 帮我们自动完成Map的初始化操作
    @Inject
    lateinit var map: Map<Int, String>

    @RequiresApi(Build.VERSION_CODES.N)
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        val daggerContainer = (application as MyApplication).getDaggerContainer()
        // 字段自动注入
        daggerContainer.injectMap(this)
        setContentView(R.layout.activity_dagger_basic)
        // 直接可以使用Map的数据
        map.forEach { (t, u) ->
            println("key:$t value:$u")
        }
    }
}
```
很简单，此时我们只有一个疑问Map<Int, String>返回值类型的数据是如何提供的？看->

```kotlin
/**
 * Create by SunnyDay /12/13 17:26:17
 */
@Module
class IntoMapModule {
    @Provides
    @IntoMap
    @IntKey(1)
    fun providerStudent1()="Tom"

    @Provides
    @IntoMap
    @IntKey(2)
    fun providerStudent2()="Kate"
}
```

然后让容器管理 ->

```kotlin
@Component(modules = [IntoMapModule::class])
interface ApplicationComponent {
     // 要通过注入方式获取
    fun injectMap(activity:DaggerBasicActivity)
}
```

注意用法细节：

- @IntoMap和@XxxKey成对出现
- @IntoMap需要结合Module的Provides食用
- map以字段注入方式使用

###### 2、custom map key

很简单假如我想使用自定义类ClassName作为key，类对象作为value：

```kotlin
/**
 * Create by SunnyDay /12/13 17:50:53
 */
open class Fragment
class HomeFragment:Fragment()
class HomeProfile:Fragment()
```

定义key注解 ->

```kotlin
/**
 * Create by SunnyDay /12/13 17:55:31
 */
@MapKey
annotation class FragmentKey(val value: KClass<out Fragment>)
```

定义Module 提供Map数据 ->

```kotlin
/**
 * Create by SunnyDay /12/13 17:54:19
 */
@Module
class FragmentModule {
    @Provides
    @IntoMap
    @FragmentKey(HomeFragment::class)
    fun providerHomeFragment() = HomeFragment()

    @Provides
    @IntoMap
    @FragmentKey(HomeFragment::class)
    fun providerProfileFragment() = ProfileFragment()
}
```




